# Cursor Rules for SaaS Boilerplate

## Project Structure & Stack

This is a Turbo monorepo with the following stack:

- **Database**: MongoDB
- **Backend**: NestJS
- **Frontend**: Next.js
- **Monorepo**: Turborepo

## Package Structure

All packages must be organized under `./packages/` directory:

```
packages/
├── frontend/          # Next.js frontend application
├── backend/           # NestJS backend services
└── shared-lib/        # Shared types and utilities
```

### Package Responsibilities

- **frontend**: Contains all frontend services, components, pages, and Next.js specific code
- **backend**: Contains all NestJS backend services, APIs, and server-side logic
- **shared-lib**: Contains shared TypeScript types, interfaces, and utilities to ensure consistency between frontend and backend

## NestJS Architecture Rules

### Module Organization

- All NestJS modules MUST be placed under `/modules` directory
- Each module should represent a distinct business domain
- Module structure: `/modules/[module_name]/`

### Schema Organization

- All MongoDB schemas MUST be placed in: `/modules/[module_name]/db/[module_name].schema.ts`
- Schema files should export the schema class and any related interfaces
- Use proper MongoDB/Mongoose decorators and validation

### Repository Pattern (CRITICAL)

- Each schema MUST have its own repository class
- Repository location: `/modules/[module_name]/db/[module_name].repository.ts`
- **NEVER call a schema directly from external services**
- **ALWAYS use the repository for database operations**
- Repository should contain all database calls for that specific schema
- Other services should only interact with repositories, never directly with schemas

## Code Generation Guidelines

### When creating new modules:

1. Create module directory: `/modules/[module_name]/`
2. Create db directory: `/modules/[module_name]/db/`
3. Create schema: `/modules/[module_name]/db/[module_name].schema.ts`
4. Create repository: `/modules/[module_name]/db/[module_name].repository.ts`
5. Create service: `/modules/[module_name]/[module_name].service.ts`
6. Create controller: `/modules/[module_name]/[module_name].controller.ts`
7. Create module file: `/modules/[module_name]/[module_name].module.ts`

### Repository Pattern Implementation

```typescript
// Example repository structure
@Injectable()
export class UserRepository {
  constructor(@InjectModel(User.name) private userModel: Model<UserDocument>) {}

  async create(userData: CreateUserDto): Promise<User> {
    // Database operation
  }

  async findById(id: string): Promise<User | null> {
    // Database operation
  }

  // All other database operations for User schema
}
```

### Service Layer Rules

- Services should inject repositories, not schemas
- Services contain business logic
- Services should not contain direct database calls

### Shared Types

- All shared interfaces and types go in `packages/shared-lib/`
- Export types that are used by both frontend and backend
- Maintain consistency between packages

## File Naming Conventions

- Schemas: `db/[module_name].schema.ts`
- Repositories: `db/[module_name].repository.ts`
- Services: `[module_name].service.ts`
- Controllers: `[module_name].controller.ts`
- Modules: `[module_name].module.ts`

## Import Rules

- Backend code should import shared types from `packages/shared-lib`
- Frontend code should import shared types from `packages/shared-lib`
- Never import backend code directly in frontend
- Use proper barrel exports in shared-lib

## Database Access Rules (CRITICAL)

1. **NEVER** import or use schema models directly in services
2. **ALWAYS** use the corresponding repository
3. **NEVER** bypass the repository pattern
4. Each schema must have exactly one repository
5. Repository is the single source of truth for database operations

## Turbo Configuration

- Ensure proper workspace dependencies in package.json
- Configure build pipelines appropriately
- Use shared configurations where possible

## Code Quality

- Use TypeScript strict mode
- Implement proper error handling
- Use dependency injection properly
- Follow NestJS best practices
- Implement proper validation using class-validator
- Use proper MongoDB/Mongoose patterns
